# -*- coding: utf-8 -*-
"""BitcoinPricePrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1os7Mhyfl85hks69bu_FARqWeQwLl3IZU

# This program uses Long Short Term Memory to predict the closing stock price. The prediction is based on the past 60 days stock price.
"""

import math
import pandas_datareader as web
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import datetime as dt

# Get the stock quote
crypto_currency = 'BTC'  # BTC
against_currency = 'EUR'
data_source ='yahoo'
period = 20

start = dt.datetime(2012, 1, 1)
end = dt.datetime.now() - dt.timedelta(period + 1)

ticket = f'{crypto_currency}-{against_currency}'

df = web.DataReader(ticket, data_source=data_source, start=start, end=end)

df.head()

df.reset_index(inplace = True)
df.set_index(["Date"])
df.head()

sma = df['Close'].rolling(window=period).mean()  # Simple moving average (SMA)
std = df['Close'].rolling(window=period).std()  # Standard deviation
df['Upper'] = sma + (std *2)  # Bollinger band
df['Lower'] = sma - (std *2)  # Bollinger band

df['Short'] = df.Close.ewm(span=20, adjust=False).mean()  # Exponential moving average
df['Long'] = df.Close.ewm(span=50, adjust=False).mean()  # Exponential moving average

df['20MA'] = df['Close'].rolling(window=20).mean()  # 20 moving average (20MA)
df['50MA'] = df['Close'].rolling(window=50).mean()  # 50 moving average (50MA)

shortema = df.Close.ewm(span=12, adjust=False).mean()  # Exponential moving average
longema = df.Close.ewm(span=26, adjust=False).mean()  # Exponential moving average
df['MACD'] = shortema - longema  # MACD
df['Signal'] = df.MACD.ewm(span=9, adjust=False).mean()  # Exponential moving average

df.head()

plt.style.use('fivethirtyeight')
plt.figure(figsize=(16, 8))
plt.title('Close Price History')
plt.plot(df['Date'], df['Close'], label='Close', color='blue')
plt.plot(df['Date'], df['20MA'], label='20MA', color='black', dashes=[3, 2])
plt.plot(df['Date'], df['50MA'], label='50MA', color='orange', dashes=[6, 2])
plt.xlabel('Date', fontsize=18)
plt.xticks(rotation = 45)
plt.ylabel('Close Price', fontsize=18)
plt.legend()
plt.show()

plt.style.use('fivethirtyeight')
plt.figure(figsize=(16, 8))
plt.title('Close Price MACD')
plt.plot(df['Date'], df['MACD'], label='MACD', color='green')
plt.plot(df['Date'], df['Signal'], label='Signal', color='purple', dashes=[3, 2])
plt.axhline(y = 0, color = 'black', dashes=[1, 2])
plt.xlabel('Date', fontsize=18)
plt.xticks(rotation = 45)
plt.ylabel('Close Price', fontsize=18)
plt.legend()
plt.show()

plt.style.use('fivethirtyeight')
fig = plt.figure(figsize=(16, 8))
ax = fig.add_subplot(1,1,1)
x_axis = df['Date']
ax.fill_between(x_axis, df['Upper'], df['Lower'], color='silver')
ax.plot(x_axis, df['Close'], color='gold', lw=3, label='Close Price')
ax.set_title('Bolinger band')
ax.set_xlabel('Date')
ax.set_ylabel('USD Price ($)')
plt.xticks(rotation = 45)
ax.legend()
plt.show()

"""
---

## **Model**
"""

# Filtering with Close Column
data = df.filter(['Close'])
dataset = data.values
training_data_len = math.ceil(len(dataset) * 0.8)

training_data_len

# Normalization
scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(dataset)

# Creating Data set
train_data = scaled_data[0:training_data_len, :]
x_train, y_train = [], []

for i in range(period, len(train_data)):
  x_train.append(train_data[i-period:i, 0])
  y_train.append(train_data[i, 0])

x_train, y_train = np.array(x_train), np.array(y_train)
x_train.shape, y_train.shape

# Reshaping the data
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
x_train.shape

# Building the model
model = Sequential()

model.add(LSTM(units=50, return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(LSTM(units=50, return_sequences=False))
model.add(Dense(units=50))
model.add(Dense(units=1))


model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=10)
# model.fit(x_train, y_train, epochs=25, batch_size=32)

# Testing Data Set
test_data = scaled_data[training_data_len - period: , :]
x_test = []
y_test = dataset[training_data_len:, :]

for i in range(period, len(test_data)):
  x_test.append(test_data[i-period:i, 0])

x_test = np.array(x_test)
x_test.shape

# Reshaping the data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))
x_test.shape

# Test the model
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)

predictions.shape

# RMSE
# rmse = np.sqrt(np.mean((predictions - y_test)**2))
# rmse = np.sqrt(np.mean(np.power((np.array(y_test) - np.array(predictions)), 2)))
rmse = np.sqrt(((predictions - y_test)**2).mean())
rmse

# Plot the data
train = data[:training_data_len]
valid = data[training_data_len:]
valid['Predictions'] = predictions

plt.figure(figsize=(16, 8))
plt.title('Model')
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD', fontsize=18)
# plt.plot(train['Close'])
plt.plot(valid[['Close', 'Predictions']])
plt.legend(['Train', 'Val', 'Predictions'], loc='lower right')
plt.show()

# Valid - Predicted
valid

# Predicted last know price
end = dt.datetime.now() - dt.timedelta(2)

df_predicted = web.DataReader(ticket, data_source=data_source, start=start, end=end)
new_df = df_predicted.filter(['Close'])
last_60_days = new_df[-period:].values
last_60_days_scaled = scaler.fit_transform(last_60_days)

X_test = []
X_test.append(last_60_days_scaled)

X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

pred_price = model.predict(X_test)
pred_price = scaler.inverse_transform(pred_price)
pred_price = round(float(pred_price[0][0]), 6)

print(f'Predicted price: ${pred_price}')

next = dt.datetime.now() - dt.timedelta(1)

df_real = web.DataReader(ticket, data_source=data_source, start=next, end=next)
real_price = df_real['Close'].values

real_price = round(float(real_price[0]), 6)
print(f'Real price: ${real_price}')

diff = (real_price - pred_price)
dffp = 100 * diff / real_price
print(f'Difference: ${round(diff,2)} {round(dffp,2)}%')

# Predicted last know price
end = dt.datetime.now()

df_predicted = web.DataReader(ticket, data_source=data_source, start=start, end=end)
new_df = df_predicted.filter(['Close'])
last_60_days = new_df[-period:].values
last_60_days_scaled = scaler.fit_transform(last_60_days)

X_test = []
X_test.append(last_60_days_scaled)

X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

pred_price = model.predict(X_test)
pred_price = scaler.inverse_transform(pred_price)
pred_price = round(float(pred_price[0][0]), 6)

print(f'Predicted price: ${pred_price}')

